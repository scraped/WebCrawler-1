// Generated by CoffeeScript 1.11.1
var ContentType, PACKETS, Parser, PriorityQueue, Request, Worker, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('lodash');

PriorityQueue = require('./Queue/PriorityQueue');

Request = require('./Requests/request');

Parser = require('./Parser');

ContentType = require('content-type');

PACKETS = {
  JOB: 0
};

Worker = (function() {
  function Worker(options) {
    this.options = options;
    this.getUrl = bind(this.getUrl, this);
    this.addEmail = bind(this.addEmail, this);
    this.loop = 0;
    this.processed = 0;
    this.domain = null;
    this.discovery = true;
    this.queue = PriorityQueue();
    this.request = new Request();
    this.parser = new Parser();
    this.crawledAt = null;
    this.sitemap = null;
    this.mode = 'email';
    this.emails = [];
    this.start();
    process.on('message', (function(_this) {
      return function(packet) {
        if (packet.type === PACKETS.JOB) {
          return _this.addJob(packet.job);
        }
      };
    })(this));
  }

  Worker.prototype.start = function() {
    return this.loop = setInterval((function(_this) {
      return function() {
        if (_this.queue.size() > 0) {
          return _this.getUrl(_this.queue.pop());
        }
      };
    })(this), this.options.workerDelay);
  };

  Worker.prototype.stop = function() {
    return clearInterval(this.loop);
  };

  Worker.prototype.addEmail = function(emails) {
    return emails.forEach((function(_this) {
      return function(email) {
        if (_this.emails.indexOf(email) === -1) {
          return _this.emails.push(_this.parser.cleanEmail(email));
        }
      };
    })(this));
  };

  Worker.prototype.addJob = function(job) {
    this.crawledAt = new Date();
    this.domain = this.parser.getDomain(job);
    return this.parser.getSitemap(job).then((function(_this) {
      return function(sitemap) {
        if (sitemap.sites.length > 0) {
          _this.discovery = false;
          return sitemap.sites.forEach(function(link, index) {
            return _this.queue.push(index, link);
          });
        } else {
          return _this.queue.push(1, job);
        }
      };
    })(this))["catch"]((function(_this) {
      return function(err) {};
    })(this));
  };

  Worker.prototype.getUrl = function(url) {
    var stats;
    stats = {
      techs: [],
      metas: {},
      url: '',
      nbLinks: 0,
      nbWords: 0,
      pageSize: 0,
      responseTime: 0,
      parsingTime: 0,
      statusCode: 0,
      contentType: null,
      charset: null,
      langs: null
    };
    return this.request.get(url).then((function(_this) {
      return function(data, langs) {
        var body, content, promises, timer;
        _this.processed++;
        if (_this.mode === 'email') {
          body = _this.parser.removeScriptsTags(_this.parser.removeStyleTags(data.body));
          _this.addEmail(_.uniq(_this.parser.getEmails(body)));
          process.stdout.write("\u001b[2J\u001b[0;0H");
          return console.log(_this.emails, _this.emails.length);
        } else if (_this.mode === 'url') {
          timer = new Date();
          stats.responseTime = data.responseTime / 1000;
          content = ContentType.parse(data.headers['content-type']);
          if (content.parameters.charset !== void 0) {
            stats.charset = content.parameters.charset.toLowerCase();
          }
          stats.url = _this.parser.getPathname(url);
          stats.statusCode = data.statusCode;
          stats.contentType = content.type;
          stats.langs = langs || null;
          promises = [_this.parser.getLinks(data.body, _this.domain), _this.parser.getWords(data.body, langs, 20), _this.parser.getMeta(url), _this.parser.getTechnologies(url)];
          return Promise.all(promises).then(function(res) {
            var links, metas, techs, words;
            links = res[0];
            words = res[1];
            metas = res[2];
            techs = res[3];
            stats.nbLinks = (links.internals.length + links.externals.length) || 0;
            stats.pageSize = _this.parser.byteCount(data.body || 0);
            stats.nbWords = words.length || 0;
            stats.parsingTime = (new Date() - timer) / 1000;
            stats.metas = metas || null;
            stats.techs = techs || null;
            stats.words = words || null;
            return console.log(_this.processed, stats);
          })["catch"](function(err) {
            return {};
          });
        }
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        return {};
      };
    })(this));
  };

  return Worker;

})();

module.exports = Worker;

//# sourceMappingURL=Worker.js.map
