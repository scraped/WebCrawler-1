// Generated by CoffeeScript 1.11.1
'use strict';
var Crawler, Master, PriorityQueue, _, cluster, ipLocation, os, simpleTimer, timer, urlParser,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('lodash');

os = require('os');

urlParser = require('url-parse');

cluster = require('cluster');

simpleTimer = require('node-timers/simple');

Crawler = require('./Crawler');

PriorityQueue = require('./Crawler/Queue/PriorityQueue');

ipLocation = require('ip-location');

timer = simpleTimer();

Master = (function() {
  function Master(opts) {
    var crawler, i, j, ref, worker;
    if (opts == null) {
      opts = {};
    }
    this.getWorkersInfos = bind(this.getWorkersInfos, this);
    this.cfg = {
      delay: 16,
      max_workers: opts.maxWorkers || 'auto'
    };
    this.stats = {};
    this.jobs = [];
    this.currentWorker = 0;
    this.exclude = ['free.fr', 'statcounter', 'doubleclick', 'feedburner', 't.co', 'facebook', 'google', 'youtube', 'twitter', 'github'];
    if (cluster.isMaster) {
      this.q = PriorityQueue();
      this.workers = [];
      for (i = j = 1, ref = this.getMaxWorkers(); 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        worker = this.spawn();
        this.stats[worker.id] = {
          domain: null,
          queue: 0,
          done: 0
        };
        this.workers.push(worker);
      }
      this.start();
      this.listenEvents((function(_this) {
        return function() {
          return _this.io.on('connection', function(socket) {
            socket.emit('started');
            socket.emit('workers', _this.getWorkersInfos());
            socket.on('stop', function() {
              return _this.stop();
            });
            socket.on('getWorkers', function() {
              return socket.emit('workers', _this.getWorkersInfos());
            });
            return socket.on('job', function(job) {
              _this.jobs.push(job);
              return _this.q.push(1, job);
            });
          });
        };
      })(this));
    } else {
      crawler = new Crawler();
      process.on('message', (function(_this) {
        return function(pkt) {
          var domain;
          if (pkt.job) {
            domain = _this.getDomain(pkt.job);
            return crawler.q.push(1, pkt.job);
          }
        };
      })(this));
    }
  }

  Master.prototype.getWorkersInfos = function() {
    var infos, j, len, ref, stat, worker;
    infos = {};
    ref = this.workers;
    for (j = 0, len = ref.length; j < len; j++) {
      worker = ref[j];
      process.stdout.write(this.stats[worker.id].toString());
      if (this.stats[worker.id] !== void 0) {
        stat = this.stats[worker.id];
      }
      infos[worker.id] = {
        id: worker.id,
        domain: stat !== void 0 ? stat.domain : void 0,
        queue: stat !== void 0 ? stat.queue : void 0,
        done: stat !== void 0 ? stat.done : void 0,
        status: worker.status
      };
    }
    return infos;
  };

  Master.prototype.listenEvents = function(cb) {
    this.io = require('socket.io')();
    this.io.listen(5002);
    return cb();
  };

  Master.prototype.getDomain = function(url) {
    return urlParser(url).hostname;
  };

  Master.prototype.isAllowed = function(url) {
    var allowed, exclude, j, len, ref;
    allowed = true;
    ref = this.exclude;
    for (j = 0, len = ref.length; j < len; j++) {
      exclude = ref[j];
      if (url.indexOf(exclude) >= 0) {
        allowed = false;
      }
    }
    return allowed;
  };

  Master.prototype.start = function() {
    setInterval((function(_this) {
      return function() {
        var total;
        total = 0;
        _this.workers.forEach(function(w) {
          if (_this.stats[w.id]) {
            total += _this.stats[w.id].done;
            return _this.io.sockets.emit('metrics', {
              done: _this.stats[w.id].done,
              queue: _this.stats[w.id].queue,
              url: _this.stats[w.id].job,
              domain: _this.stats[w.id].domain,
              id: w.id
            });
          }
        });
        return _this.io.sockets.emit('masterMetrics', {
          totalLinks: total,
          queue: _this.q.size(),
          jobs: _this.jobs
        });
      };
    })(this), 100);
    return this.interval = setInterval((function(_this) {
      return function() {
        var job, worker;
        if (_this.q.size() > 0) {
          worker = _this.getRandomWorker();
          if (worker) {
            job = _this.q.pop();
            if (_this.isAllowed(_this.getDomain(job)) && (_this.stats[worker.id].domain === _this.getDomain(job) || _this.stats[worker.id].domain === null)) {
              return worker.send({
                job: job
              });
            }
          }
        }
      };
    })(this), this.cfg.delay);
  };

  Master.prototype.stop = function() {
    clearInterval(this.interval);
    return this.io.sockets.emit('stopped');
  };

  Master.prototype.getMaxWorkers = function() {
    if (this.cfg.max_workers === 'auto') {
      return os.cpus().length;
    }
    return this.cfg.max_workers;
  };

  Master.prototype.spawn = function() {
    var fork;
    fork = cluster.fork();
    fork.on('message', (function(_this) {
      return function(pkt) {
        if (pkt.queue && pkt.domain && pkt.done && pkt.job) {
          _this.q.push(1, pkt.job);
          if (!_this.stats[fork.id]) {
            _this.stats[fork.id] = {
              done: 0,
              url: null,
              queue: 0,
              id: fork.id,
              domain: null
            };
          }
          _this.stats[fork.id].done = pkt.done;
          _this.stats[fork.id].queue = pkt.queue;
          _this.stats[fork.id].job = pkt.job;
          return _this.stats[fork.id].domain = pkt.domain;
        }
      };
    })(this));
    return fork.on('exit', (function(_this) {
      return function(id) {
        return console.log("Worker " + id + " died... respawning worker !");
      };
    })(this));
  };

  Master.prototype.getNextWorker = function() {
    this.currentWorker++;
    if (this.currentWorker > this.getMaxWorkers()) {
      this.currentWorker = 0;
    }
    return this.workers.forEach((function(_this) {
      return function(w) {
        if (w.id === _this.currentWorker) {
          return w;
        }
      };
    })(this));
  };

  Master.prototype.getLazyWorker = function() {
    return this.workers[0];
  };

  Master.prototype.getRandomWorker = function() {
    return this.workers[~~(this.workers.length * Math.random())];
  };

  return Master;

})();

module.exports = Master;

//# sourceMappingURL=Master.js.map
