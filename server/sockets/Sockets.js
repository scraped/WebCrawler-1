// Generated by CoffeeScript 1.11.1
var SocketManager, Sockets, childProcess, clientManager, io, jwt;

io = require('socket.io');

jwt = require('jsonwebtoken');

clientManager = require('client-manager');

SocketManager = require('./SocketManager');

childProcess = require('child_process');

module.exports = Sockets = (function() {
  function Sockets(app, server) {
    this.app = app;
    this.server = server;
    this.app.io = io(this.server);
    this.manager = clientManager();
    this.socketManager = new SocketManager(this.manager);
    this.app.socketManager = this.socketManager;
    this.listenEvents();
    this.app.logger.info('âœ“ '.bold.green + 'Started sockets handler.');
  }

  Sockets.prototype.listenEvents = function() {
    this.crawler_socket = require('socket.io-client')('http://localhost:5002');
    this.app.io.on('connection', (function(_this) {
      return function(socket) {
        _this.crawler_socket.on('started', function() {
          return socket.emit('masterStarted');
        });
        _this.crawler_socket.on('stopped', function() {
          return socket.emit('masterStopped');
        });
        _this.crawler_socket.on('workers', function(workers) {
          return socket.emit('workers', workers);
        });
        _this.crawler_socket.on('metrics', function(metrics) {
          return socket.emit('crawlerMetrics', metrics);
        });
        _this.crawler_socket.on('masterMetrics', function(metrics) {
          return socket.emit('masterMetrics', metrics);
        });
        socket.on('join', function(data) {
          return jwt.verify(data.authorization, _this.app.config.jwt_secret, function(err, user) {
            if (err === null) {
              user.status = 'online';
              socket.user = user;
              _this.manager.addClient(user.id, socket);
              _this.socketManager.getClients().forEach(function(client) {
                return socket.emit('onUserStatus', client);
              });
              return socket.broadcast.emit('onUserStatus', _this.socketManager.getClient(user.id));
            }
          });
        });
        socket.on('crawler:start', function(opts) {
          var crawler;
          crawler = childProcess.spawn('node', ['crawler.js', JSON.stringify(opts)]);
          crawler.stdout.on('data', function(data) {
            return console.log(new Buffer(data).toString('utf8'));
          });
          return crawler.stderr.on('data', function(err) {
            return console.log(new Buffer(err).toString('utf8'));
          });
        });
        socket.on('crawler:getWorkers', function() {
          return _this.crawler_socket.emit('getWorkers');
        });
        socket.on('crawler:job', function(job) {
          return _this.crawler_socket.emit('job', job);
        });
        socket.on('crawler:stop', function() {
          return _this.crawler_socket.emit('stop');
        });
        return socket.on('disconnect', function() {
          var client;
          client = _this.socketManager.getClientBySocketId(socket.id);
          if (client !== null) {
            client.status = 'offline';
            socket.broadcast.emit('onUserstatus', client);
            _this.manager.removeClient(client.id);
            return _this.app.logger.info(client.firstname + " " + client.lastname + " has disconnected");
          }
        });
      };
    })(this));
    this.manager.on('add', (function(_this) {
      return function(client) {
        return _this.app.logger.info(client.user.firstname + " " + client.user.lastname + " is connected");
      };
    })(this));
    return this.manager.on('empty', (function(_this) {
      return function() {
        return _this.app.logger.info('No more sockets connected');
      };
    })(this));
  };

  return Sockets;

})();

//# sourceMappingURL=Sockets.js.map
